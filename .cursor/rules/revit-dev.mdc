---
alwaysApply: true
---

# Standards

This document is a living document, and should be updated as project standards
evolve. These are the guiding principles:

- fail fast, fail loudly, fail early
- make composable systems
- type-safety at all costs
- linear execution flow, easy debugability
- wrap bad Revit API entities

## List of Acronyms

- RA: Revit API
- DX: Developer Experience
- UX: User Experience
- FF: Family Foundry

## Testing & POC'ing & Exploring (LAUNCHPAD)

The easiest way to test is by writing test scripts into
C:\Users\kaitp\OneDrive\Documents\ArchSmarter\Launchpad VS
Code\LaunchpadScripts. This is a sandbox env that allows us to run arbitrary
code, see C:\Users\kaitp\OneDrive\Documents\ArchSmarter\Launchpad VS
Code\.cursor\rules\launchpad-development.mdc for reference on usage.

Usually when you want to test something in this project, you have to make a
whole new IExternalCommand, this sucks. The sandbox env allows us to not pollute
our main project codebase with test code if for example you want to

- see how a Revit API method behaves
- you want to test a method/class in PE_Tools, or you want to POC/MVP a new one
  to add to PE_Tools
- or anything adjacent to this

## For Agents

### Do's

Follow, but also think critically about existing patterns. We want consistency
and the (mostly) ideal solution. Refactor effort is not a concern. If you see an
opportunity to improve a pattern/system in a way that it still serves all its
consumers, then suggest it.

Think deeply about publicly exposed API surfaces and architecture choices.
Library code should balance the tradeoffs of being intuitive to use and general
purpose.

**Always ask before building the solution.** The user will often be inside of a
Rider debug session attached to Revit, rebuilding breaks this. If ok, then build
to check your work if the breadth of a change is big, or if your expectations
and LSP are at odds. Use commands that minimize output like
`dotnet build -c "Debug.R25" -nologo -clp:NoSummary /p:WarningLevel=0`

Exceptions should generally be avoided, prefer the `Result<TValue>` or `Try...`
patterns, particularly if it's part of the public API surface and/or may be
exposed to users. using the `Result<TValue` type allows us to _return_ errors
rather than throw, which is better for perf. For both DX posterity, record
common footguns/suggestions in error messages, for example: special transaction
needs for RA methods, a method (eg. FamilyManager.SetFormula) throw unhelpful
error messages, etc.

Reduce nesting in written code and stacktraces. Use method extraction or
condition inversion to avoid nesting in written code. Prefer sequential
execution flow with early `return`/`break`/`continue`/`throw` over nesting.

Type-safety do's: label/handle nullables correctly, use generics, use
`nameof()`, us ``is` and pattern matching,

Use LINQ and Fluent APIs when possible.

Use extension methods to get commonly used finicky code out of sight.\

Research the breath of a problem and attempt to prove it before trying to solve
it.

### Don'ts

- Write markdown summaries unless asked
- Nest `for` loops or `if` statements more than 4 times in a single method.
- Type-safety don'ts: use reflection, use `!`, use `object` or `dynamic` type,
  cast down
- Rebuild the project without asking first. The user will often be inside of a
  Rider debug session attached to Revit, rebuilding breaks this, forcing them to
  restart.
