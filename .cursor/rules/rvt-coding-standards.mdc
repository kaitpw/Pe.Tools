---
alwaysApply: true
---

# PE_Tools Revit Add-in Development Rules

## CODE STYLE - NEVER-NESTERS & FAIL-FASTERS

- **AVOID nesting `if` more than twice**. Try to do the same with all nesting C#
  keywords. 3 layers is permissible but discouraged, 4+ is not unforgivable.
- Use separate `if` statements for multiple conditions. Early `return`/`break`
  is better than `else if`/`else`
- To solve nesting: 1) extract logic to functions, 2) invert conditionals and
  return early
- Throw descriptive Exceptions for critical dependencies instead of broad `if`
  checks. Execution flow should be as linear as possible.
- Prefer generics and interfaces over `object` type and casts.
- Use LINQ and Fluent APIs

## GENERAL PREFERENCES

- **We LOVE the Strategy Pattern**. Inheritance is the devil. Interfaces are
  your friend.
- Prefer dependency injection over internal instantiation
- Use generic types in primitive/library functions
- Favor sequential calls over deeply nested method chains
- Extension methods and private members are invaluable for reducing public API
  surface

## WPF & UI (ALWAYS use WPF + CommunityToolkit.Mvvm)

- Use singletons for stateful add-ins (startup performance)
- Cast DataContext in code-behind:
  `private MyViewModel _viewModel => DataContext as MyViewModel;`

## REVIT ADD-IN PATTERNS

- Cmd[Name].cs files in main project implement IExternalCommand
- Call shared project code from cmd files
- App.cs handles IExternalApplication and creates Revit UI. Add Cmds to UI here.
- Place complex add-in code in LibraryAddins/Addin[Name]/ folders

## PROJECT STRUCTURE

- Library/ - reusable shared projects (PeRevit.Lib, PeRevit.Mep, etc.)
- LibraryAddins/ - complex add-in implementations
- PE_Tools/ - main orchestrating project
- Always use Shared.props for shared project properties

## PERFORMANCE & SECURITY

- Handle errors early with guard clauses
- Use custom error types with structured messages
- Implement comprehensive testing (unit, integration, e2e)
- Validate all inputs, use HTTPS, implement proper auth
- Optimize for Core Web Vitals and efficient queries

## TESTING & EXPLORATION (LAUNCHPAD)

The easiest way to test is by writing test scripts into
C:\Users\kaitp\OneDrive\Documents\ArchSmarter\Launchpad VS
Code\LaunchpadScripts. This is a sandbox env that allows us to run arbitrary
code, see C:\Users\kaitp\OneDrive\Documents\ArchSmarter\Launchpad VS
Code\.cursor\rules\launchpad-development.mdc for reference on usage.

Usually when you want to test something in this project, you have to make a
whole new IExternalCommand, this sucks. The sandbox env allows us to not pollute
our main project codebase with test code if for example you want to

- see how a Revit API method behaves
- you want to test a method/class in PE_Tools, or you want to POC/MVP a new one
  to add to PE_Tools
- or anything adjacent to this
